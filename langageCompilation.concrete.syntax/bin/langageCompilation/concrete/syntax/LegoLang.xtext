// automatically generated by Xtext
grammar langageCompilation.concrete.syntax.LegoLang with org.eclipse.xtext.common.Terminals

import "http://www.example.org/langageCompilation" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Program returns Program:
	{Program}
	'Program'
	name=EString
	'{'
		(statement+=Statement)*  (';')? 
	'}';

Statement returns Statement:
	WhileLoop | Variable | Expression | ConditionEtat | MethodePrint | Car | Sensor | Engine | Pause;

Expression returns Expression:
	VariableRef | BinaryOperation | TheString | TheColor | TheDouble | TheInt | TheBoolean | EngineOperation | BreakMotor | SensorOperation | BooleanExpression ;

BinaryOperation returns BinaryOperation:
	Substraction | Comparaison | Assignement | Division | Multiplication | Addition | MinusEqual | PlusEqual;
	
Variable returns Variable:
	UnInteger | UnString | UnBoolean | UnDouble | UnColor;

Comparaison returns Comparaison:
	  GT | Equal | LT | Different | GTorEqual | LTorEqual ;

Engine returns Engine:
	WheelEngine | MotorizedArmEngine | PaintballLauncherEngine;

Sensor returns Sensor:
	LaserSensor | ColorSensor | UltraSonicSensor | GyroSensor | GPSSensor;

Pause returns Pause:
	'stop''for' expression=Expression 
;

WheelEngine returns WheelEngine:
	'WheelEngine'
	name=EString 
	'on'
	position=EString
;
MotorizedArmEngine returns MotorizedArmEngine:
	'MotorizedArmEngine'
	name=EString 
	'on'
	position=EString
;

PaintballLauncherEngine returns PaintballLauncherEngine:
	'PaintballLauncherEngine'
	name=EString 
	'on'
	position=EString
;
ColorSensor returns ColorSensor:
	'ColorSensor'
	name=EString
	'on'
	position=EInt
;

LaserSensor returns LaserSensor:
	'LaserSensor'
	name=EString
	'on'
	position=EInt
;

GPSSensor returns GPSSensor:
	'GPSSensor'
	name=EString
	'on'
	position=EInt
;

GyroSensor returns GyroSensor:
	'GyroSensor'
	name=EString
	'on'
	position=EInt
;

UltraSonicSensor returns UltraSonicSensor:
	'UltraSonicSensor'
	name=EString
	'on'
	position=EInt
;

Car returns Car:
	'Car'
	name=EString
	'{'
		(sensor+=Sensor)*
		(engine+=Engine)*
	
	'}'
;

EngineOperation returns EngineOperation:
	 VitesseOperation | PositionOperation | ForceOperation 
;

SensorOperation returns SensorOperation:
	RangeOperation | ColorOperation | IntensityOperation | XGPSOperation | YGPSOperation | AngleOperation | DistanceOperation ;

VitesseOperation returns VitesseOperation:
	'set' 'vitesse''('wheelengine=[WheelEngine|FQN]')'
	'='
	right=Expression
;

BreakMotor returns BreakMotor:
	'break' 'motor' '('engine=[Engine|FQN]')'
;
PositionOperation returns PositionOperation:
	'set' 'degres''('motorizedarmengine=[MotorizedArmEngine|FQN]')'
	'='
	right=Expression
;

ForceOperation returns ForceOperation:
	'set' 'strength''('paintballlauncherengine=[PaintballLauncherEngine|FQN]')'
	'='
	right=Expression
;
ColorOperation returns ColorOperation:
	'get''color''('colorsensor=[ColorSensor|FQN]')'
;

IntensityOperation returns IntensityOperation:
	'get''intensity''('colorsensor=[ColorSensor|FQN]')'
;

RangeOperation returns RangeOperation:
	'get''range''('lasersensor=[LaserSensor|FQN]')'
;

XGPSOperation returns XGPSOperation:
	'get''x''('gpssensor=[GPSSensor|FQN]')'
;

YGPSOperation returns YGPSOperation:
	'get''y''('gpssensor=[GPSSensor|FQN]')'
;

AngleOperation returns AngleOperation:
	'get''angle''('gyrosensor=[GyroSensor|FQN]')'
;

DistanceOperation returns DistanceOperation:
	'get''distance''('ultrasonicsensor=[UltraSonicSensor|FQN]')'
;

BooleanExpression returns BooleanExpression:
	And | Or
;

And returns And:
	{And}
	'('(left=Expression)
	('and' right=Expression)?
	')'
;

Or returns Or:
	{Or}
	'('(left=Expression)
	('or' right=Expression)?
	')'
;

ConditionEtat returns ConditionEtat:
	'if'
		Condition=BooleanExpression '{'
			(then+=Statement )*
		'}'
		('else{'else+=Statement'}' )?
	;

EString returns ecore::EString:
	FQN | ID;



WhileLoop returns WhileLoop:
	'while'
		LoopCondition=BooleanExpression
	'{'
		(statement+=Statement )*
	'}';
	
MethodePrint returns MethodePrint:
	{MethodePrint}
	'print('
	(expression+=Expression)
	(',' expression+=Expression)*
	')';
	
VariableRef returns VariableRef:
	variable=[Variable|EString]
	;

Substraction returns Substraction:
	   '(' left=Expression '-'
		right=Expression ')'
	;
	
Addition returns Addition:
	   '(' left=Expression '+'
		right=Expression ')'
	;
	
Multiplication returns Multiplication:
	   '(' left=Expression '*'
		right=Expression ')'
	;
	
Division returns Division:
	   '(' left=Expression '/'
		right=Expression ')'
	;

GT returns GT:
	'(' left=Expression '>'
	right=Expression ')';

LT returns LT:
	'(' left=Expression '<'
	right=Expression ')';
	
Equal returns Equal:
	'(' left=Expression '=='
	right=Expression ')';
	
Different returns Different:
	'(' left=Expression '!='
	right=Expression ')';


LTorEqual returns LTorEqual:
	'(' left=Expression '<='
	right=Expression ')';

GTorEqual returns GTorEqual:
	'(' left=Expression '>='
	right=Expression ')';
	
Assignement returns Assignement:
	{Assignement}
	'set' left=Expression
	'=' right= Expression  
	;

PlusEqual returns PlusEqual:
	{PlusEqual}
	'('left=Expression
	'+=' right= Expression ')' 
	;

MinusEqual returns MinusEqual:
	{MinusEqual}
	'('left=Expression
	'-=' right= Expression ')'
	;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

UnInteger returns UnInteger:
	{UnInteger}
	(isConst?='const')?
	'int'
	name=EString
	('=' initialeValue=EInt)? ;

UnDouble returns UnDouble:
	{UnDouble}
	(isConst?='const')?
	'double'
	name=EString
	('=' initialeValue1=EInt '.' initialeValue2=EInt)? ;

UnBoolean returns UnBoolean:
	{UnBoolean}
	(isConst?='const')?
	'bool'
	name=EString
	('=' initialeValue=EBoolean)?; 
	
UnString returns UnString:
	{UnString}
	(isConst?='const')?
	'string'
	name=EString
	('=' initialeValue=STRING)?;
	
UnColor returns UnColor:
	{UnColor}
	(isConst?='const')?
	'color'
	name=EString
	('=' initialValue =Colors )?;

TheDouble returns TheDouble:
	{TheDouble}
	value1=EInt '.' value2=EInt ;
	
TheInt returns TheInt:
	{TheInt}
	value=EInt;
	
TheBoolean returns TheBoolean:
	{TheBoolean}
	value=EBoolean;

TheString returns TheString:
	{TheString}
	value=STRING;
TheColor returns TheColor:
	{TheColor}
	value=Colors;

enum Colors:
black = "black" | white = "white"	
;
FQN :
	ID('.'ID)*
;
EInt returns ecore::EInt:
	'-'? INT;
	

