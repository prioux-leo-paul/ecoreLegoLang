/*
 * generated by Xtext 2.25.0
 */
package langageCompilation.concrete.syntax.serializer;

import com.google.inject.Inject;
import java.util.Set;
import langageCompilation.Addition;
import langageCompilation.And;
import langageCompilation.AngleOperation;
import langageCompilation.Assignement;
import langageCompilation.Car;
import langageCompilation.ColorOperation;
import langageCompilation.ColorSensor;
import langageCompilation.ConditionEtat;
import langageCompilation.Different;
import langageCompilation.DistanceOperation;
import langageCompilation.Division;
import langageCompilation.Equal;
import langageCompilation.GPSSensor;
import langageCompilation.GT;
import langageCompilation.GTorEqual;
import langageCompilation.GyroSensor;
import langageCompilation.IntensityOperation;
import langageCompilation.LT;
import langageCompilation.LTorEqual;
import langageCompilation.LangageCompilationPackage;
import langageCompilation.LaserSensor;
import langageCompilation.MethodePrint;
import langageCompilation.MinusEqual;
import langageCompilation.Multiplication;
import langageCompilation.Or;
import langageCompilation.PlusEqual;
import langageCompilation.Program;
import langageCompilation.RangeOperation;
import langageCompilation.Substraction;
import langageCompilation.TheBoolean;
import langageCompilation.TheDouble;
import langageCompilation.TheInt;
import langageCompilation.TheString;
import langageCompilation.UltraSonicSensor;
import langageCompilation.UnBoolean;
import langageCompilation.UnDouble;
import langageCompilation.UnInteger;
import langageCompilation.UnString;
import langageCompilation.VariableRef;
import langageCompilation.VitesseOperation;
import langageCompilation.WheelEngine;
import langageCompilation.WhileLoop;
import langageCompilation.XGPSOperation;
import langageCompilation.YGPSOperation;
import langageCompilation.concrete.syntax.services.LegoLangGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LegoLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LegoLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LangageCompilationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LangageCompilationPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case LangageCompilationPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case LangageCompilationPackage.ANGLE_OPERATION:
				sequence_AngleOperation(context, (AngleOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.ASSIGNEMENT:
				sequence_Assignement(context, (Assignement) semanticObject); 
				return; 
			case LangageCompilationPackage.CAR:
				sequence_Car(context, (Car) semanticObject); 
				return; 
			case LangageCompilationPackage.COLOR_OPERATION:
				sequence_ColorOperation(context, (ColorOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.COLOR_SENSOR:
				sequence_ColorSensor(context, (ColorSensor) semanticObject); 
				return; 
			case LangageCompilationPackage.CONDITION_ETAT:
				sequence_ConditionEtat(context, (ConditionEtat) semanticObject); 
				return; 
			case LangageCompilationPackage.DIFFERENT:
				sequence_Different(context, (Different) semanticObject); 
				return; 
			case LangageCompilationPackage.DISTANCE_OPERATION:
				sequence_DistanceOperation(context, (DistanceOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.DIVISION:
				sequence_Division(context, (Division) semanticObject); 
				return; 
			case LangageCompilationPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case LangageCompilationPackage.GPS_SENSOR:
				sequence_GPSSensor(context, (GPSSensor) semanticObject); 
				return; 
			case LangageCompilationPackage.GT:
				sequence_GT(context, (GT) semanticObject); 
				return; 
			case LangageCompilationPackage.GTOR_EQUAL:
				sequence_GTorEqual(context, (GTorEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.GYRO_SENSOR:
				sequence_GyroSensor(context, (GyroSensor) semanticObject); 
				return; 
			case LangageCompilationPackage.INTENSITY_OPERATION:
				sequence_IntensityOperation(context, (IntensityOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.LT:
				sequence_LT(context, (LT) semanticObject); 
				return; 
			case LangageCompilationPackage.LTOR_EQUAL:
				sequence_LTorEqual(context, (LTorEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.LASER_SENSOR:
				sequence_LaserSensor(context, (LaserSensor) semanticObject); 
				return; 
			case LangageCompilationPackage.METHODE_PRINT:
				sequence_MethodePrint(context, (MethodePrint) semanticObject); 
				return; 
			case LangageCompilationPackage.MINUS_EQUAL:
				sequence_MinusEqual(context, (MinusEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case LangageCompilationPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case LangageCompilationPackage.PLUS_EQUAL:
				sequence_PlusEqual(context, (PlusEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case LangageCompilationPackage.RANGE_OPERATION:
				sequence_RangeOperation(context, (RangeOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.SUBSTRACTION:
				sequence_Substraction(context, (Substraction) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_BOOLEAN:
				sequence_TheBoolean(context, (TheBoolean) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_DOUBLE:
				sequence_TheDouble(context, (TheDouble) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_INT:
				sequence_TheInt(context, (TheInt) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_STRING:
				sequence_TheString(context, (TheString) semanticObject); 
				return; 
			case LangageCompilationPackage.ULTRA_SONIC_SENSOR:
				sequence_UltraSonicSensor(context, (UltraSonicSensor) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_BOOLEAN:
				sequence_UnBoolean(context, (UnBoolean) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_DOUBLE:
				sequence_UnDouble(context, (UnDouble) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_INTEGER:
				sequence_UnInteger(context, (UnInteger) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_STRING:
				sequence_UnString(context, (UnString) semanticObject); 
				return; 
			case LangageCompilationPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case LangageCompilationPackage.VITESSE_OPERATION:
				sequence_VitesseOperation(context, (VitesseOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.WHEEL_ENGINE:
				sequence_WheelEngine(context, (WheelEngine) semanticObject); 
				return; 
			case LangageCompilationPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			case LangageCompilationPackage.XGPS_OPERATION:
				sequence_XGPSOperation(context, (XGPSOperation) semanticObject); 
				return; 
			case LangageCompilationPackage.YGPS_OPERATION:
				sequence_YGPSOperation(context, (YGPSOperation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns Addition
	 *     Expression returns Addition
	 *     BinaryOperation returns Addition
	 *     Addition returns Addition
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns And
	 *     Expression returns And
	 *     BooleanExpression returns And
	 *     And returns And
	 *
	 * Constraint:
	 *     (left=Expression right=Expression?)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AngleOperation
	 *     Expression returns AngleOperation
	 *     SensorOperation returns AngleOperation
	 *     AngleOperation returns AngleOperation
	 *
	 * Constraint:
	 *     gyrosensor=[GyroSensor|FQN]
	 */
	protected void sequence_AngleOperation(ISerializationContext context, AngleOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.ANGLE_OPERATION__GYROSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.ANGLE_OPERATION__GYROSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAngleOperationAccess().getGyrosensorGyroSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.ANGLE_OPERATION__GYROSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignement
	 *     Expression returns Assignement
	 *     BinaryOperation returns Assignement
	 *     Assignement returns Assignement
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Assignement(ISerializationContext context, Assignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignementAccess().getLeftExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignementAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Car
	 *     Car returns Car
	 *
	 * Constraint:
	 *     (name=EString sensor+=Sensor* engine+=Engine*)
	 */
	protected void sequence_Car(ISerializationContext context, Car semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ColorOperation
	 *     Expression returns ColorOperation
	 *     SensorOperation returns ColorOperation
	 *     ColorOperation returns ColorOperation
	 *
	 * Constraint:
	 *     colorsensor=[ColorSensor|FQN]
	 */
	protected void sequence_ColorOperation(ISerializationContext context, ColorOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.COLOR_OPERATION__COLORSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.COLOR_OPERATION__COLORSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorOperationAccess().getColorsensorColorSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.COLOR_OPERATION__COLORSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ColorSensor
	 *     Sensor returns ColorSensor
	 *     ColorSensor returns ColorSensor
	 *
	 * Constraint:
	 *     (name=EString position=EInt)
	 */
	protected void sequence_ColorSensor(ISerializationContext context, ColorSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColorSensorAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getColorSensorAccess().getPositionEIntParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConditionEtat
	 *     ConditionEtat returns ConditionEtat
	 *
	 * Constraint:
	 *     (Condition=BooleanExpression then+=Statement* else+=Statement?)
	 */
	protected void sequence_ConditionEtat(ISerializationContext context, ConditionEtat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Different
	 *     Expression returns Different
	 *     BinaryOperation returns Different
	 *     Comparaison returns Different
	 *     Different returns Different
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Different(ISerializationContext context, Different semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDifferentAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDifferentAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DistanceOperation
	 *     Expression returns DistanceOperation
	 *     SensorOperation returns DistanceOperation
	 *     DistanceOperation returns DistanceOperation
	 *
	 * Constraint:
	 *     ultrasonicsensor=[UltraSonicSensor|FQN]
	 */
	protected void sequence_DistanceOperation(ISerializationContext context, DistanceOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.DISTANCE_OPERATION__ULTRASONICSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.DISTANCE_OPERATION__ULTRASONICSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDistanceOperationAccess().getUltrasonicsensorUltraSonicSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.DISTANCE_OPERATION__ULTRASONICSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Division
	 *     Expression returns Division
	 *     BinaryOperation returns Division
	 *     Division returns Division
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Division(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivisionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Equal
	 *     Expression returns Equal
	 *     BinaryOperation returns Equal
	 *     Comparaison returns Equal
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GPSSensor
	 *     Sensor returns GPSSensor
	 *     GPSSensor returns GPSSensor
	 *
	 * Constraint:
	 *     (name=EString position=EInt)
	 */
	protected void sequence_GPSSensor(ISerializationContext context, GPSSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGPSSensorAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGPSSensorAccess().getPositionEIntParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GT
	 *     Expression returns GT
	 *     BinaryOperation returns GT
	 *     Comparaison returns GT
	 *     GT returns GT
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_GT(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGTAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGTAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GTorEqual
	 *     Expression returns GTorEqual
	 *     BinaryOperation returns GTorEqual
	 *     Comparaison returns GTorEqual
	 *     GTorEqual returns GTorEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_GTorEqual(ISerializationContext context, GTorEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGTorEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGTorEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GyroSensor
	 *     Sensor returns GyroSensor
	 *     GyroSensor returns GyroSensor
	 *
	 * Constraint:
	 *     (name=EString position=EInt)
	 */
	protected void sequence_GyroSensor(ISerializationContext context, GyroSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGyroSensorAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getGyroSensorAccess().getPositionEIntParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntensityOperation
	 *     Expression returns IntensityOperation
	 *     SensorOperation returns IntensityOperation
	 *     IntensityOperation returns IntensityOperation
	 *
	 * Constraint:
	 *     colorsensor=[ColorSensor|FQN]
	 */
	protected void sequence_IntensityOperation(ISerializationContext context, IntensityOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.INTENSITY_OPERATION__COLORSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.INTENSITY_OPERATION__COLORSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntensityOperationAccess().getColorsensorColorSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.INTENSITY_OPERATION__COLORSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LT
	 *     Expression returns LT
	 *     BinaryOperation returns LT
	 *     Comparaison returns LT
	 *     LT returns LT
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_LT(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLTAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LTorEqual
	 *     Expression returns LTorEqual
	 *     BinaryOperation returns LTorEqual
	 *     Comparaison returns LTorEqual
	 *     LTorEqual returns LTorEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_LTorEqual(ISerializationContext context, LTorEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTorEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLTorEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LaserSensor
	 *     Sensor returns LaserSensor
	 *     LaserSensor returns LaserSensor
	 *
	 * Constraint:
	 *     (name=EString position=EInt)
	 */
	protected void sequence_LaserSensor(ISerializationContext context, LaserSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLaserSensorAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLaserSensorAccess().getPositionEIntParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MethodePrint
	 *     MethodePrint returns MethodePrint
	 *
	 * Constraint:
	 *     expression+=Expression+
	 */
	protected void sequence_MethodePrint(ISerializationContext context, MethodePrint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MinusEqual
	 *     Expression returns MinusEqual
	 *     BinaryOperation returns MinusEqual
	 *     MinusEqual returns MinusEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_MinusEqual(ISerializationContext context, MinusEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusEqualAccess().getLeftExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinusEqualAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Multiplication
	 *     Expression returns Multiplication
	 *     BinaryOperation returns Multiplication
	 *     Multiplication returns Multiplication
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Or
	 *     Expression returns Or
	 *     BooleanExpression returns Or
	 *     Or returns Or
	 *
	 * Constraint:
	 *     (left=Expression right=Expression?)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlusEqual
	 *     Expression returns PlusEqual
	 *     BinaryOperation returns PlusEqual
	 *     PlusEqual returns PlusEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_PlusEqual(ISerializationContext context, PlusEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusEqualAccess().getLeftExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusEqualAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=EString statement+=Statement*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RangeOperation
	 *     Expression returns RangeOperation
	 *     SensorOperation returns RangeOperation
	 *     RangeOperation returns RangeOperation
	 *
	 * Constraint:
	 *     lasersensor=[LaserSensor|FQN]
	 */
	protected void sequence_RangeOperation(ISerializationContext context, RangeOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.RANGE_OPERATION__LASERSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.RANGE_OPERATION__LASERSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeOperationAccess().getLasersensorLaserSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.RANGE_OPERATION__LASERSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Substraction
	 *     Expression returns Substraction
	 *     BinaryOperation returns Substraction
	 *     Substraction returns Substraction
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Substraction(ISerializationContext context, Substraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstractionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubstractionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheBoolean
	 *     Expression returns TheBoolean
	 *     TheBoolean returns TheBoolean
	 *
	 * Constraint:
	 *     value=EBoolean
	 */
	protected void sequence_TheBoolean(ISerializationContext context, TheBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheBooleanAccess().getValueEBooleanParserRuleCall_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheDouble
	 *     Expression returns TheDouble
	 *     TheDouble returns TheDouble
	 *
	 * Constraint:
	 *     (value1=EInt value2=EInt)
	 */
	protected void sequence_TheDouble(ISerializationContext context, TheDouble semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_DOUBLE__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_DOUBLE__VALUE1));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_DOUBLE__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_DOUBLE__VALUE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheDoubleAccess().getValue1EIntParserRuleCall_1_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getTheDoubleAccess().getValue2EIntParserRuleCall_3_0(), semanticObject.getValue2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheInt
	 *     Expression returns TheInt
	 *     TheInt returns TheInt
	 *
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_TheInt(ISerializationContext context, TheInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheIntAccess().getValueEIntParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheString
	 *     Expression returns TheString
	 *     TheString returns TheString
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_TheString(ISerializationContext context, TheString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheStringAccess().getValueEStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UltraSonicSensor
	 *     Sensor returns UltraSonicSensor
	 *     UltraSonicSensor returns UltraSonicSensor
	 *
	 * Constraint:
	 *     (name=EString position=EInt)
	 */
	protected void sequence_UltraSonicSensor(ISerializationContext context, UltraSonicSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.SENSOR__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUltraSonicSensorAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUltraSonicSensorAccess().getPositionEIntParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnBoolean
	 *     Variable returns UnBoolean
	 *     UnBoolean returns UnBoolean
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString initialeValue=EBoolean?)
	 */
	protected void sequence_UnBoolean(ISerializationContext context, UnBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnDouble
	 *     Variable returns UnDouble
	 *     UnDouble returns UnDouble
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString (initialeValue1=EInt initialeValue2=EInt?)?)
	 */
	protected void sequence_UnDouble(ISerializationContext context, UnDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnInteger
	 *     Variable returns UnInteger
	 *     UnInteger returns UnInteger
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString initialeValue=EInt?)
	 */
	protected void sequence_UnInteger(ISerializationContext context, UnInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns UnString
	 *     Variable returns UnString
	 *     UnString returns UnString
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString initialeValue=EString?)
	 */
	protected void sequence_UnString(ISerializationContext context, UnString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableRef
	 *     Expression returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=[Variable|EString]
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableVariableEStringParserRuleCall_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.VARIABLE_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VitesseOperation
	 *     Expression returns VitesseOperation
	 *     EngineOperation returns VitesseOperation
	 *     VitesseOperation returns VitesseOperation
	 *
	 * Constraint:
	 *     (wheelengine=[WheelEngine|FQN] right=Expression)
	 */
	protected void sequence_VitesseOperation(ISerializationContext context, VitesseOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.VITESSE_OPERATION__WHEELENGINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.VITESSE_OPERATION__WHEELENGINE));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.ENGINE_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.ENGINE_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVitesseOperationAccess().getWheelengineWheelEngineFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.VITESSE_OPERATION__WHEELENGINE, false));
		feeder.accept(grammarAccess.getVitesseOperationAccess().getRightExpressionParserRuleCall_6_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WheelEngine
	 *     Engine returns WheelEngine
	 *     WheelEngine returns WheelEngine
	 *
	 * Constraint:
	 *     (name=EString position=EString)
	 */
	protected void sequence_WheelEngine(ISerializationContext context, WheelEngine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.ENGINE__POSITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.ENGINE__POSITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWheelEngineAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getWheelEngineAccess().getPositionEStringParserRuleCall_2_0(), semanticObject.getPosition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (LoopCondition=BooleanExpression statement+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns XGPSOperation
	 *     Expression returns XGPSOperation
	 *     SensorOperation returns XGPSOperation
	 *     XGPSOperation returns XGPSOperation
	 *
	 * Constraint:
	 *     gpssensor=[GPSSensor|FQN]
	 */
	protected void sequence_XGPSOperation(ISerializationContext context, XGPSOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.XGPS_OPERATION__GPSSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.XGPS_OPERATION__GPSSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXGPSOperationAccess().getGpssensorGPSSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.XGPS_OPERATION__GPSSENSOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns YGPSOperation
	 *     Expression returns YGPSOperation
	 *     SensorOperation returns YGPSOperation
	 *     YGPSOperation returns YGPSOperation
	 *
	 * Constraint:
	 *     gpssensor=[GPSSensor|FQN]
	 */
	protected void sequence_YGPSOperation(ISerializationContext context, YGPSOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.YGPS_OPERATION__GPSSENSOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.YGPS_OPERATION__GPSSENSOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYGPSOperationAccess().getGpssensorGPSSensorFQNParserRuleCall_3_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.YGPS_OPERATION__GPSSENSOR, false));
		feeder.finish();
	}
	
	
}
