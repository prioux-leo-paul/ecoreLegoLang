/*
 * generated by Xtext 2.25.0
 */
package langageCompilation.concrete.syntax.serializer;

import com.google.inject.Inject;
import java.util.Set;
import langageCompilation.Addition;
import langageCompilation.Assignement;
import langageCompilation.ConditionEtat;
import langageCompilation.Different;
import langageCompilation.Division;
import langageCompilation.Equal;
import langageCompilation.GT;
import langageCompilation.GTorEqual;
import langageCompilation.LT;
import langageCompilation.LTorEqual;
import langageCompilation.LangageCompilationPackage;
import langageCompilation.MethodePrint;
import langageCompilation.MinusEqual;
import langageCompilation.Multiplication;
import langageCompilation.PlusEqual;
import langageCompilation.Program;
import langageCompilation.Substraction;
import langageCompilation.TheBoolean;
import langageCompilation.TheDouble;
import langageCompilation.TheInt;
import langageCompilation.TheString;
import langageCompilation.VariableRef;
import langageCompilation.WhileLoop;
import langageCompilation.concrete.syntax.services.LegoLangGrammarAccess;
import langageCompilation.unBoolean;
import langageCompilation.unDouble;
import langageCompilation.unInteger;
import langageCompilation.unString;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LegoLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LegoLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LangageCompilationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LangageCompilationPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case LangageCompilationPackage.ASSIGNEMENT:
				sequence_Assignement(context, (Assignement) semanticObject); 
				return; 
			case LangageCompilationPackage.CONDITION_ETAT:
				sequence_ConditionEtat(context, (ConditionEtat) semanticObject); 
				return; 
			case LangageCompilationPackage.DIFFERENT:
				sequence_Different(context, (Different) semanticObject); 
				return; 
			case LangageCompilationPackage.DIVISION:
				sequence_Division(context, (Division) semanticObject); 
				return; 
			case LangageCompilationPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case LangageCompilationPackage.GT:
				sequence_GT(context, (GT) semanticObject); 
				return; 
			case LangageCompilationPackage.GTOR_EQUAL:
				sequence_GTorEqual(context, (GTorEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.LT:
				sequence_LT(context, (LT) semanticObject); 
				return; 
			case LangageCompilationPackage.LTOR_EQUAL:
				sequence_LTorEqual(context, (LTorEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.METHODE_PRINT:
				sequence_MethodePrint(context, (MethodePrint) semanticObject); 
				return; 
			case LangageCompilationPackage.MINUS_EQUAL:
				sequence_MinusEqual(context, (MinusEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case LangageCompilationPackage.PLUS_EQUAL:
				sequence_PlusEqual(context, (PlusEqual) semanticObject); 
				return; 
			case LangageCompilationPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case LangageCompilationPackage.SUBSTRACTION:
				sequence_Substraction(context, (Substraction) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_BOOLEAN:
				sequence_TheBoolean(context, (TheBoolean) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_DOUBLE:
				sequence_TheDouble(context, (TheDouble) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_INT:
				sequence_TheInt(context, (TheInt) semanticObject); 
				return; 
			case LangageCompilationPackage.THE_STRING:
				sequence_TheString(context, (TheString) semanticObject); 
				return; 
			case LangageCompilationPackage.VARIABLE_REF:
				sequence_VariableRef(context, (VariableRef) semanticObject); 
				return; 
			case LangageCompilationPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_BOOLEAN:
				sequence_unBoolean(context, (unBoolean) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_DOUBLE:
				sequence_unDouble(context, (unDouble) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_INTEGER:
				sequence_unInteger(context, (unInteger) semanticObject); 
				return; 
			case LangageCompilationPackage.UN_STRING:
				sequence_unString(context, (unString) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns Addition
	 *     Expression returns Addition
	 *     BinaryOperation returns Addition
	 *     Addition returns Addition
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignement
	 *     Expression returns Assignement
	 *     BinaryOperation returns Assignement
	 *     Assignement returns Assignement
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Assignement(ISerializationContext context, Assignement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignementAccess().getLeftExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignementAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ConditionEtat
	 *     ConditionEtat returns ConditionEtat
	 *
	 * Constraint:
	 *     (Condition=Comparaison then+=Statement* else+=Statement?)
	 */
	protected void sequence_ConditionEtat(ISerializationContext context, ConditionEtat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Different
	 *     Expression returns Different
	 *     BinaryOperation returns Different
	 *     Comparaison returns Different
	 *     Different returns Different
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Different(ISerializationContext context, Different semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDifferentAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDifferentAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Division
	 *     Expression returns Division
	 *     BinaryOperation returns Division
	 *     Division returns Division
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Division(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDivisionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getDivisionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Equal
	 *     Expression returns Equal
	 *     BinaryOperation returns Equal
	 *     Comparaison returns Equal
	 *     Equal returns Equal
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GT
	 *     Expression returns GT
	 *     BinaryOperation returns GT
	 *     Comparaison returns GT
	 *     GT returns GT
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_GT(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGTAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGTAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns GTorEqual
	 *     Expression returns GTorEqual
	 *     BinaryOperation returns GTorEqual
	 *     Comparaison returns GTorEqual
	 *     GTorEqual returns GTorEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_GTorEqual(ISerializationContext context, GTorEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGTorEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getGTorEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LT
	 *     Expression returns LT
	 *     BinaryOperation returns LT
	 *     Comparaison returns LT
	 *     LT returns LT
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_LT(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLTAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LTorEqual
	 *     Expression returns LTorEqual
	 *     BinaryOperation returns LTorEqual
	 *     Comparaison returns LTorEqual
	 *     LTorEqual returns LTorEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_LTorEqual(ISerializationContext context, LTorEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLTorEqualAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLTorEqualAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MethodePrint
	 *     MethodePrint returns MethodePrint
	 *
	 * Constraint:
	 *     expression+=Expression+
	 */
	protected void sequence_MethodePrint(ISerializationContext context, MethodePrint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns MinusEqual
	 *     Expression returns MinusEqual
	 *     BinaryOperation returns MinusEqual
	 *     MinusEqual returns MinusEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_MinusEqual(ISerializationContext context, MinusEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinusEqualAccess().getLeftExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMinusEqualAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Multiplication
	 *     Expression returns Multiplication
	 *     BinaryOperation returns Multiplication
	 *     Multiplication returns Multiplication
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlusEqual
	 *     Expression returns PlusEqual
	 *     BinaryOperation returns PlusEqual
	 *     PlusEqual returns PlusEqual
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_PlusEqual(ISerializationContext context, PlusEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusEqualAccess().getLeftExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusEqualAccess().getRightExpressionParserRuleCall_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=EString statement+=Statement*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Substraction
	 *     Expression returns Substraction
	 *     BinaryOperation returns Substraction
	 *     Substraction returns Substraction
	 *
	 * Constraint:
	 *     (left=Expression right=Expression)
	 */
	protected void sequence_Substraction(ISerializationContext context, Substraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubstractionAccess().getLeftExpressionParserRuleCall_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSubstractionAccess().getRightExpressionParserRuleCall_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheBoolean
	 *     Expression returns TheBoolean
	 *     TheBoolean returns TheBoolean
	 *
	 * Constraint:
	 *     value=EBoolean
	 */
	protected void sequence_TheBoolean(ISerializationContext context, TheBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheBooleanAccess().getValueEBooleanParserRuleCall_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheDouble
	 *     Expression returns TheDouble
	 *     TheDouble returns TheDouble
	 *
	 * Constraint:
	 *     (value1=EInt value2=EInt?)
	 */
	protected void sequence_TheDouble(ISerializationContext context, TheDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheInt
	 *     Expression returns TheInt
	 *     TheInt returns TheInt
	 *
	 * Constraint:
	 *     value=EInt
	 */
	protected void sequence_TheInt(ISerializationContext context, TheInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheIntAccess().getValueEIntParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns TheString
	 *     Expression returns TheString
	 *     TheString returns TheString
	 *
	 * Constraint:
	 *     value=EString
	 */
	protected void sequence_TheString(ISerializationContext context, TheString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.THE_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.THE_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTheStringAccess().getValueEStringParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableRef
	 *     Expression returns VariableRef
	 *     VariableRef returns VariableRef
	 *
	 * Constraint:
	 *     variable=[Variable|EString]
	 */
	protected void sequence_VariableRef(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LangageCompilationPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LangageCompilationPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableRefAccess().getVariableVariableEStringParserRuleCall_0_1(), semanticObject.eGet(LangageCompilationPackage.Literals.VARIABLE_REF__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (LoopCondition=Comparaison statement+=Statement*)
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns unBoolean
	 *     Variable returns unBoolean
	 *     unBoolean returns unBoolean
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString initialeValue=EBoolean?)
	 */
	protected void sequence_unBoolean(ISerializationContext context, unBoolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns unDouble
	 *     Variable returns unDouble
	 *     unDouble returns unDouble
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString (initialeValue1=EInt initialeValue2=EInt?)?)
	 */
	protected void sequence_unDouble(ISerializationContext context, unDouble semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns unInteger
	 *     Variable returns unInteger
	 *     unInteger returns unInteger
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString initialeValue=EInt?)
	 */
	protected void sequence_unInteger(ISerializationContext context, unInteger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns unString
	 *     Variable returns unString
	 *     unString returns unString
	 *
	 * Constraint:
	 *     (isConst?='const'? name=EString initialeValue=EString?)
	 */
	protected void sequence_unString(ISerializationContext context, unString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
